(self.webpackChunkan_onchain_app_in_100_components=self.webpackChunkan_onchain_app_in_100_components||[]).push([[711],{"./node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{E:()=>EndDateSchema,R:()=>RawDateSchema,S:()=>StartDateSchema,a:()=>assertEnabled});var ethers__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"),zod__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/zod/lib/index.mjs"),_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js");const RawDateSchema=(()=>zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.date().transform((i=>ethers__WEBPACK_IMPORTED_MODULE_1__.gH.from(Math.floor(i.getTime()/1e3)))),zod__WEBPACK_IMPORTED_MODULE_0__.z.number().transform((i=>ethers__WEBPACK_IMPORTED_MODULE_1__.gH.from(i)))]))(),StartDateSchema=(()=>RawDateSchema.default(new Date(0)))(),EndDateSchema=(()=>RawDateSchema.default(new Date(Date.now()+31536e7)))();function assertEnabled(namespace,feature){if(!namespace)throw new _index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.x(feature);return namespace}},"./node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{B:()=>BasicNFTInput,C:()=>CommonNFTInput,N:()=>NFTInputOrUriSchema,a:()=>CommonNFTOutput,s:()=>setErc20Allowance});var _index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js"),zod__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/zod/lib/index.mjs"),_fetchCurrencyValue_32d08b05_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js");const PropertiesInput=(()=>zod__WEBPACK_IMPORTED_MODULE_0__.z.object({}).catchall(zod__WEBPACK_IMPORTED_MODULE_0__.z.union([_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cx,zod__WEBPACK_IMPORTED_MODULE_0__.z.unknown()])))(),OptionalPropertiesInput=(()=>zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.array(PropertiesInput)).transform((i=>i.flat())),zod__WEBPACK_IMPORTED_MODULE_0__.z.array(PropertiesInput),PropertiesInput]).optional().nullable())(),BasicNFTInput=(()=>zod__WEBPACK_IMPORTED_MODULE_0__.z.object({name:zod__WEBPACK_IMPORTED_MODULE_0__.z.union([zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),zod__WEBPACK_IMPORTED_MODULE_0__.z.number()]).optional().nullable(),description:zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable().optional().nullable(),image:_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cy.nullable().optional(),animation_url:_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cy.optional().nullable()}))(),CommonNFTInput=(()=>BasicNFTInput.extend({external_url:_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cy.nullable().optional(),background_color:_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cz.optional().nullable(),properties:OptionalPropertiesInput,attributes:OptionalPropertiesInput}).catchall(zod__WEBPACK_IMPORTED_MODULE_0__.z.union([_index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cx,zod__WEBPACK_IMPORTED_MODULE_0__.z.unknown()])))(),NFTInputOrUriSchema=(()=>zod__WEBPACK_IMPORTED_MODULE_0__.z.union([CommonNFTInput,zod__WEBPACK_IMPORTED_MODULE_0__.z.string()]))(),CommonNFTOutput=(()=>CommonNFTInput.extend({id:zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),uri:zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),image:zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable().optional(),external_url:zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable().optional(),animation_url:zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable().optional()}))();async function setErc20Allowance(contractToApprove,value,currencyAddress,overrides){if(!(0,_fetchCurrencyValue_32d08b05_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.i)(currencyAddress)){const ERC20Abi=(await Promise.resolve().then(__webpack_require__.t.bind(__webpack_require__,"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json",19))).default,signer=contractToApprove.getSigner(),provider=contractToApprove.getProvider(),erc20=new _index_33cd3415_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.cs(signer||provider,currencyAddress,ERC20Abi,contractToApprove.options,contractToApprove.storage),owner=await contractToApprove.getSignerAddress(),spender=contractToApprove.address;return(await erc20.read("allowance",[owner,spender])).lt(value)&&await erc20.sendTransaction("approve",[spender,value]),overrides}overrides.value=value}},"./node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>newContractModelToAbstract,B:()=>BaseSignaturePayloadInput,C:()=>ClaimEligibility,D:()=>convertQuantityToBigNumber,E:()=>prepareClaim,F:()=>SnapshotFormatVersion,H:()=>processClaimConditionInputs,I:()=>abstractContractModelToLegacy,J:()=>abstractContractModelToNew,K:()=>updateExistingClaimConditions,L:()=>resolveOrGenerateId,M:()=>MintRequest20,S:()=>Signature20PayloadInput,a:()=>approveErc20Allowance,f:()=>fetchSnapshotEntryForAddress,n:()=>Signature20PayloadOutput,r:()=>Signature1155PayloadInputWithTokenId,s:()=>Signature1155PayloadOutput,t:()=>Signature721WithQuantityInput,u:()=>Signature721WithQuantityOutput,v:()=>MintRequest721,w:()=>MintRequest1155,x:()=>MintRequest721withQuantity,y:()=>transformResultToClaimCondition,z:()=>legacyContractModelToAbstract});var bignumbers=__webpack_require__("./node_modules/@ethersproject/constants/lib.esm/bignumbers.js"),lib_esm=__webpack_require__("./node_modules/@ethersproject/units/lib.esm/index.js"),solidity_lib_esm=__webpack_require__("./node_modules/@ethersproject/solidity/lib.esm/index.js"),addresses=__webpack_require__("./node_modules/@ethersproject/constants/lib.esm/addresses.js"),keccak256_lib_esm=__webpack_require__("./node_modules/@ethersproject/keccak256/lib.esm/index.js"),bignumber=__webpack_require__("./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"),bytes_lib_esm=__webpack_require__("./node_modules/@ethersproject/bytes/lib.esm/index.js"),utf8=__webpack_require__("./node_modules/@ethersproject/strings/lib.esm/utf8.js"),index_33cd3415_browser_esm=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js"),fetchCurrencyValue_32d08b05_browser_esm=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js"),normalizePriceValue_9851c0eb_browser_esm=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js"),buffer=__webpack_require__("./node_modules/buffer/index.js"),buffer_reverse=__webpack_require__("./node_modules/buffer-reverse/index.js"),buffer_reverse_default=__webpack_require__.n(buffer_reverse),treeify=__webpack_require__("./node_modules/treeify/treeify.js"),console=__webpack_require__("./node_modules/console-browserify/index.js");class Base{print(){Base.print(this)}bufferIndexOf(array,element){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(array,element,buffer.Buffer.compare);return this.linearSearch(array,element,((buffer1,buffer2)=>buffer1.equals(buffer2)))}static binarySearch(array,element,compareFunction){let start=0,end=array.length-1;for(;start<=end;){const mid=Math.floor((start+end)/2),ordering=compareFunction(array[mid],element);if(0===ordering){for(let i=mid-1;i>=0;i--)if(0!==compareFunction(array[i],element))return i+1;return 0}ordering<0?start=mid+1:end=mid-1}return-1}binarySearch(array,element,compareFunction){return Base.binarySearch(array,element,compareFunction)}static linearSearch(array,element,eqChecker){for(let i=0;i<array.length;i++)if(eqChecker(array[i],element))return i;return-1}linearSearch(array,element,eqChecker){return Base.linearSearch(array,element,eqChecker)}static bufferify(value){if(!buffer.Buffer.isBuffer(value)){if("object"==typeof value&&value.words)return buffer.Buffer.from(value.toString(convertWordsToBuffer),"hex");if(Base.isHexString(value))return buffer.Buffer.from(value.replace(/^0x/,""),"hex");if("string"==typeof value)return buffer.Buffer.from(value);if("bigint"==typeof value)return buffer.Buffer.from(value.toString(16),"hex");if(value instanceof Uint8Array)return buffer.Buffer.from(value.buffer);if("number"==typeof value){let s=value.toString();return s.length%2&&(s=`0${s}`),buffer.Buffer.from(s,"hex")}if(ArrayBuffer.isView(value))return buffer.Buffer.from(value.buffer,value.byteOffset,value.byteLength)}return value}bigNumberify(value){return Base.bigNumberify(value)}static bigNumberify(value){if("bigint"==typeof value)return value;if("string"==typeof value)return value.startsWith("0x")&&Base.isHexString(value)?BigInt("0x"+value.replace("0x","").toString()):BigInt(value);if(buffer.Buffer.isBuffer(value))return BigInt("0x"+value.toString("hex"));if(value instanceof Uint8Array)return function uint8ArrayToBigInt(u8a){const hex=Array.from(u8a).map((byte=>byte.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${hex}`)}(value);if("number"==typeof value)return BigInt(value);throw new Error("cannot bigNumberify")}static isHexString(v){return"string"==typeof v&&/^(0x)?[0-9A-Fa-f]*$/.test(v)}static print(tree){console.log(tree.toString())}bufferToHex(value){let withPrefix=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return Base.bufferToHex(value,withPrefix)}static bufferToHex(value){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(value||buffer.Buffer.alloc(0)).toString("hex")}`}bufferify(value){return Base.bufferify(value)}bufferifyFn(f){return value=>{const v=f(value);if(buffer.Buffer.isBuffer(v))return v;if(this.isHexString(v))return buffer.Buffer.from(v.replace("0x",""),"hex");if("string"==typeof v)return buffer.Buffer.from(v);if("bigint"==typeof v)return buffer.Buffer.from(value.toString(16),"hex");if(ArrayBuffer.isView(v))return buffer.Buffer.from(v.buffer,v.byteOffset,v.byteLength);const arrayBuffer=function hexStringToArrayBuffer(hexString){const buffer=new Uint8Array(hexString.length/2);for(let i=0;i<hexString.length;i+=2)buffer[i/2]=parseInt(hexString.substring(i,i+2),16);return buffer.buffer}(value.toString("hex")),hexResult=function arrayBufferToHexString(arrayBuffer){const uint8View=new Uint8Array(arrayBuffer);return Array.from(uint8View).map((byte=>byte.toString(16).padStart(2,"0"))).join("")}(f(arrayBuffer));return buffer.Buffer.from(hexResult,"hex")}}isHexString(value){return Base.isHexString(value)}log2(n){return 1===n?0:1+this.log2(n/2|0)}zip(a,b){return a.map(((e,i)=>[e,b[i]]))}static hexZeroPad(hexStr,length){return"0x"+hexStr.replace("0x","").padStart(length,"0")}}var Base$1=Base;function convertWordsToBuffer(value){const wordArray=value.words,arrayBuffer=new ArrayBuffer(4*wordArray.length),uint8View=new Uint8Array(arrayBuffer);for(let i=0;i<wordArray.length;i++)uint8View[4*i]=wordArray[i]>>24&255,uint8View[4*i+1]=wordArray[i]>>16&255,uint8View[4*i+2]=wordArray[i]>>8&255,uint8View[4*i+3]=255&wordArray[i];return arrayBuffer}class thirdweb_dev_merkletree_esm_MerkleTree extends Base$1{duplicateOdd=!1;concatenator=buffer.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(leaves,hashFn){let options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),options.complete){if(options.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(options.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!options.isBitcoinTree,this.hashLeaves=!!options.hashLeaves,this.sortLeaves=!!options.sortLeaves,this.sortPairs=!!options.sortPairs,this.complete=!!options.complete,options.fillDefaultHash)if("function"==typeof options.fillDefaultHash)this.fillDefaultHash=options.fillDefaultHash;else{if(!buffer.Buffer.isBuffer(options.fillDefaultHash)&&"string"!=typeof options.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(idx,hashFn)=>options.fillDefaultHash}this.sort=!!options.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!options.duplicateOdd,options.concatenator&&(this.concatenator=options.concatenator),this.hashFn=this.bufferifyFn(hashFn),this.processLeaves(leaves)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(leaves){if(this.hashLeaves&&(leaves=leaves.map(this.hashFn)),this.leaves=leaves.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(buffer.Buffer.compare)),this.fillDefaultHash)for(let i=this.leaves.length;i<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));i++)this.leaves.push(this.bufferify(this.fillDefaultHash(i,this.hashFn)));this.createHashes(this.leaves)}createHashes(nodes){for(this.layers=[nodes];nodes.length>1;){const layerIndex=this.layers.length;this.layers.push([]);const layerLimit=this.complete&&1===layerIndex&&!Number.isInteger(Math.log2(nodes.length))?2*nodes.length-2**Math.ceil(Math.log2(nodes.length)):nodes.length;for(let i=0;i<nodes.length;i+=2){if(i>=layerLimit){this.layers[layerIndex].push(...nodes.slice(layerLimit));break}if(i+1===nodes.length&&nodes.length%2==1){const data=nodes[nodes.length-1];let hash=data;if(this.isBitcoinTree){hash=this.hashFn(this.concatenator([buffer_reverse_default()(data),buffer_reverse_default()(data)])),hash=buffer_reverse_default()(this.hashFn(hash)),this.layers[layerIndex].push(hash);continue}if(!this.duplicateOdd){this.layers[layerIndex].push(nodes[i]);continue}}const left=nodes[i],right=i+1===nodes.length?left:nodes[i+1];let combined=null;combined=this.isBitcoinTree?[buffer_reverse_default()(left),buffer_reverse_default()(right)]:[left,right],this.sortPairs&&combined.sort(buffer.Buffer.compare);let hash=this.hashFn(this.concatenator(combined));this.isBitcoinTree&&(hash=buffer_reverse_default()(this.hashFn(hash))),this.layers[layerIndex].push(hash)}nodes=this.layers[layerIndex]}}addLeaf(leaf){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(leaf=this.hashFn(leaf)),this.processLeaves(this.leaves.concat(leaf))}addLeaves(leaves){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(leaves=leaves.map(this.hashFn)),this.processLeaves(this.leaves.concat(leaves))}getLeaves(values){return Array.isArray(values)?(this.hashLeaves&&(values=values.map(this.hashFn),this.sortLeaves&&(values=values.sort(buffer.Buffer.compare))),this.leaves.filter((leaf=>-1!==this.bufferIndexOf(values,leaf,this.sortLeaves)))):this.leaves}getLeaf(index){return index<0||index>this.leaves.length-1?buffer.Buffer.from([]):this.leaves[index]}getLeafIndex(target){target=this.bufferify(target);const leaves=this.getLeaves();for(let i=0;i<leaves.length;i++){if(leaves[i].equals(target))return i}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((leaf=>this.bufferToHex(leaf)))}static marshalLeaves(leaves){return JSON.stringify(leaves.map((leaf=>thirdweb_dev_merkletree_esm_MerkleTree.bufferToHex(leaf))),null,2)}static unmarshalLeaves(jsonStr){let parsed=null;if("string"==typeof jsonStr)parsed=JSON.parse(jsonStr);else{if(!(jsonStr instanceof Object))throw new Error("Expected type of string or object");parsed=jsonStr}if(!parsed)return[];if(!Array.isArray(parsed))throw new Error("Expected JSON string to be array");return parsed.map(thirdweb_dev_merkletree_esm_MerkleTree.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((acc,item)=>(Array.isArray(item)?acc.push(item.map((layer=>this.bufferToHex(layer)))):acc.push(item),acc)),[])}getLayersFlat(){const layers=this.layers.reduce(((acc,item)=>(Array.isArray(item)?acc.unshift(...item):acc.unshift(item),acc)),[]);return layers.unshift(buffer.Buffer.from([0])),layers}getHexLayersFlat(){return this.getLayersFlat().map((layer=>this.bufferToHex(layer)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?buffer.Buffer.from([]):this.layers[this.layers.length-1][0]||buffer.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(leaf,index){if(void 0===leaf)throw new Error("leaf is required");leaf=this.bufferify(leaf);const proof=[];if(!Number.isInteger(index)){index=-1;for(let i=0;i<this.leaves.length;i++)0===buffer.Buffer.compare(leaf,this.leaves[i])&&(index=i)}if(index<=-1)return[];for(let i=0;i<this.layers.length;i++){const layer=this.layers[i],isRightNode=index%2,pairIndex=isRightNode?index-1:this.isBitcoinTree&&index===layer.length-1&&i<this.layers.length-1?index:index+1;pairIndex<layer.length&&proof.push({position:isRightNode?"left":"right",data:layer[pairIndex]}),index=index/2|0}return proof}getHexProof(leaf,index){return this.getProof(leaf,index).map((item=>this.bufferToHex(item.data)))}getProofs(){const proofs=[];return this.getProofsDFS(this.layers.length-1,0,[],proofs),proofs}getProofsDFS(currentLayer,index,proof,proofs){const isRightNode=index%2;if(-1===currentLayer)return void(isRightNode||proofs.push([...proof].reverse()));if(index>=this.layers[currentLayer].length)return;const layer=this.layers[currentLayer],pairIndex=isRightNode?index-1:index+1;let pushed=!1;pairIndex<layer.length&&(pushed=!0,proof.push({position:isRightNode?"left":"right",data:layer[pairIndex]}));const leftchildIndex=2*index,rightchildIndex=2*index+1;this.getProofsDFS(currentLayer-1,leftchildIndex,proof,proofs),this.getProofsDFS(currentLayer-1,rightchildIndex,proof,proofs),pushed&&proof.splice(proof.length-1,1)}getHexProofs(){return this.getProofs().map((item=>this.bufferToHex(item.data)))}getPositionalHexProof(leaf,index){return this.getProof(leaf,index).map((item=>["left"===item.position?0:1,this.bufferToHex(item.data)]))}getProofIndices(treeIndices,depth){const leafCount=2**depth;let maximalIndices=new Set;for(const index of treeIndices){let x=leafCount+index;for(;x>1;)maximalIndices.add(1^x),x=x/2|0}const a=treeIndices.map((index=>leafCount+index)),b=Array.from(maximalIndices).sort(((x,y)=>x-y)).reverse();maximalIndices=a.concat(b);const redundantIndices=new Set,proof=[];for(let index of maximalIndices)if(!redundantIndices.has(index))for(proof.push(index);index>1&&(redundantIndices.add(index),redundantIndices.has(1^index));)index=index/2|0;return proof.filter((index=>!treeIndices.includes(index-leafCount)))}getProofIndicesForUnevenTree(sortedLeafIndices,leavesCount){const depth=Math.ceil(Math.log2(leavesCount)),unevenLayers=[];for(let index=0;index<depth;index++){leavesCount%2!=0&&unevenLayers.push({index,leavesCount}),leavesCount=Math.ceil(leavesCount/2)}const proofIndices=[];let layerNodes=sortedLeafIndices;for(let layerIndex=0;layerIndex<depth;layerIndex++){let proofNodeIndices=layerNodes.map((index=>index%2==0?index+1:index-1)).filter((index=>!layerNodes.includes(index)));const unevenLayer=unevenLayers.find((_ref=>{let{index}=_ref;return index===layerIndex}));unevenLayer&&layerNodes.includes(unevenLayer.leavesCount-1)&&(proofNodeIndices=proofNodeIndices.slice(0,-1)),proofIndices.push(proofNodeIndices),layerNodes=[...new Set(layerNodes.map((index=>index%2==0?index/2:index%2==0?(index+1)/2:(index-1)/2)))]}return proofIndices}getMultiProof(tree,indices){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),indices||(indices=tree,tree=this.getLayersFlat());if(this.isUnevenTree()&&indices.every(Number.isInteger))return this.getMultiProofForUnevenTree(indices);if(!indices.every(Number.isInteger)){let els=indices;this.sortPairs&&(els=els.sort(buffer.Buffer.compare));let ids=els.map((el=>this.bufferIndexOf(this.leaves,el,this.sortLeaves))).sort(((a,b)=>a===b?0:a>b?1:-1));if(!ids.every((idx=>-1!==idx)))throw new Error("Element does not exist in Merkle tree");const hashes=[],proof=[];let nextIds=[];for(let i=0;i<this.layers.length;i++){const layer=this.layers[i];for(let j=0;j<ids.length;j++){const idx=ids[j],pairElement=this.getPairNode(layer,idx);hashes.push(layer[idx]),pairElement&&proof.push(pairElement),nextIds.push(idx/2|0)}ids=nextIds.filter(((value,j,self)=>self.indexOf(value)===j)),nextIds=[]}return proof.filter((value=>!hashes.includes(value)))}return this.getProofIndices(indices,Math.log2(tree.length/2|0)).map((index=>tree[index]))}getMultiProofForUnevenTree(tree,indices){indices||(indices=tree,tree=this.getLayers());let proofHashes=[],currentLayerIndices=indices;for(const treeLayer of tree){const siblings=[];for(const index of currentLayerIndices){if(index%2==0){const idx=index+1;if(!currentLayerIndices.includes(idx)&&treeLayer[idx]){siblings.push(treeLayer[idx]);continue}}const idx=index-1;currentLayerIndices.includes(idx)||!treeLayer[idx]||siblings.push(treeLayer[idx])}proofHashes=proofHashes.concat(siblings);const uniqueIndices=new Set;for(const index of currentLayerIndices)index%2!=0?index%2!=0?uniqueIndices.add((index-1)/2):uniqueIndices.add((index+1)/2):uniqueIndices.add(index/2);currentLayerIndices=Array.from(uniqueIndices)}return proofHashes}getHexMultiProof(tree,indices){return this.getMultiProof(tree,indices).map((x=>this.bufferToHex(x)))}getProofFlags(leaves,proofs){if(!Array.isArray(leaves)||leaves.length<=0)throw new Error("Invalid Inputs!");let ids;if(ids=leaves.every(Number.isInteger)?[...leaves].sort(((a,b)=>a===b?0:a>b?1:-1)):leaves.map((el=>this.bufferIndexOf(this.leaves,el,this.sortLeaves))).sort(((a,b)=>a===b?0:a>b?1:-1)),!ids.every((idx=>-1!==idx)))throw new Error("Element does not exist in Merkle tree");const _proofs=proofs.map((item=>this.bufferify(item))),tested=[],flags=[];for(let index=0;index<this.layers.length;index++){const layer=this.layers[index];ids=ids.reduce(((ids_,idx)=>{if(!tested.includes(layer[idx])){const pairElement=this.getPairNode(layer,idx),proofUsed=_proofs.includes(layer[idx])||_proofs.includes(pairElement);pairElement&&flags.push(!proofUsed),tested.push(layer[idx]),tested.push(pairElement)}return ids_.push(idx/2|0),ids_}),[])}return flags}verify(proof,targetNode,root){let hash=this.bufferify(targetNode);if(root=this.bufferify(root),!Array.isArray(proof)||!targetNode||!root)return!1;for(let i=0;i<proof.length;i++){const node=proof[i];let data=null,isLeftNode=null;if("string"==typeof node)data=this.bufferify(node),isLeftNode=!0;else if(Array.isArray(node))isLeftNode=0===node[0],data=this.bufferify(node[1]);else if(buffer.Buffer.isBuffer(node))data=node,isLeftNode=!0;else{if(!(node instanceof Object))throw new Error("Expected node to be of type string or object");data=this.bufferify(node.data),isLeftNode="left"===node.position}const buffers=[];this.isBitcoinTree?(buffers.push(buffer_reverse_default()(hash)),buffers[isLeftNode?"unshift":"push"](buffer_reverse_default()(data)),hash=this.hashFn(this.concatenator(buffers)),hash=buffer_reverse_default()(this.hashFn(hash))):this.sortPairs?-1===buffer.Buffer.compare(hash,data)?(buffers.push(hash,data),hash=this.hashFn(this.concatenator(buffers))):(buffers.push(data,hash),hash=this.hashFn(this.concatenator(buffers))):(buffers.push(hash),buffers[isLeftNode?"unshift":"push"](data),hash=this.hashFn(this.concatenator(buffers)))}return 0===buffer.Buffer.compare(hash,root)}verifyMultiProof(root,proofIndices,proofLeaves,leavesCount,proof){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(root,proofIndices,proofLeaves,leavesCount,proof);const depth=Math.ceil(Math.log2(leavesCount));root=this.bufferify(root),proofLeaves=proofLeaves.map((leaf=>this.bufferify(leaf))),proof=proof.map((leaf=>this.bufferify(leaf)));const tree={};for(const[index,leaf]of this.zip(proofIndices,proofLeaves))tree[2**depth+index]=leaf;for(const[index,proofitem]of this.zip(this.getProofIndices(proofIndices,depth),proof))tree[index]=proofitem;let indexqueue=Object.keys(tree).map((value=>Number(value))).sort(((a,b)=>a-b));indexqueue=indexqueue.slice(0,indexqueue.length-1);let i=0;for(;i<indexqueue.length;){const index=indexqueue[i];if(index>=2&&{}.hasOwnProperty.call(tree,1^index)){let pair=[tree[index-index%2],tree[index-index%2+1]];this.sortPairs&&(pair=pair.sort(buffer.Buffer.compare));const hash=pair[1]?this.hashFn(this.concatenator(pair)):pair[0];tree[index/2|0]=hash,indexqueue.push(index/2|0)}i+=1}return!proofIndices.length||{}.hasOwnProperty.call(tree,1)&&tree[1].equals(root)}verifyMultiProofWithFlags(root,leaves,proofs,proofFlag){root=this.bufferify(root),leaves=leaves.map(this.bufferify),proofs=proofs.map(this.bufferify);const leavesLen=leaves.length,totalHashes=proofFlag.length,hashes=[];let leafPos=0,hashPos=0,proofPos=0;for(let i=0;i<totalHashes;i++){const buffers=[proofFlag[i]?leafPos<leavesLen?leaves[leafPos++]:hashes[hashPos++]:proofs[proofPos++],leafPos<leavesLen?leaves[leafPos++]:hashes[hashPos++]].sort(buffer.Buffer.compare);hashes[i]=this.hashFn(this.concatenator(buffers))}return 0===buffer.Buffer.compare(hashes[totalHashes-1],root)}verifyMultiProofForUnevenTree(root,indices,leaves,leavesCount,proof){root=this.bufferify(root),leaves=leaves.map((leaf=>this.bufferify(leaf))),proof=proof.map((leaf=>this.bufferify(leaf)));const computedRoot=this.calculateRootForUnevenTree(indices,leaves,leavesCount,proof);return root.equals(computedRoot)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const layers=this.getLayers().map((layer=>layer.map((value=>this.bufferToHex(value,!1))))),objs=[];for(let i=0;i<layers.length;i++){const arr=[];for(let j=0;j<layers[i].length;j++){const obj={[layers[i][j]]:null};if(objs.length){obj[layers[i][j]]={};const a=objs.shift(),akey=Object.keys(a)[0];if(obj[layers[i][j]][akey]=a[akey],objs.length){const b=objs.shift(),bkey=Object.keys(b)[0];obj[layers[i][j]][bkey]=b[bkey]}}arr.push(obj)}objs.push(...arr)}return objs[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(layer,idx){const pairIdx=idx%2==0?idx+1:idx-1;return pairIdx<layer.length?layer[pairIdx]:null}toTreeString(){const obj=this.getLayersAsObject();return(0,treeify.asTree)(obj,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(treeLayers){const depth=treeLayers?.length||this.getDepth();return!this.isPowOf2(depth)}isPowOf2(v){return v&&!(v&v-1)}calculateRootForUnevenTree(leafIndices,leafHashes,totalLeavesCount,proofHashes){const leafTuples=this.zip(leafIndices,leafHashes).sort(((_ref2,_ref3)=>{let[indexA]=_ref2,[indexB]=_ref3;return indexA-indexB})),leafTupleIndices=leafTuples.map((_ref4=>{let[index]=_ref4;return index})),proofIndices=this.getProofIndicesForUnevenTree(leafTupleIndices,totalLeavesCount);let nextSliceStart=0;const proofTuplesByLayers=[];for(let i=0;i<proofIndices.length;i++){const indices=proofIndices[i],sliceStart=nextSliceStart;nextSliceStart+=indices.length,proofTuplesByLayers[i]=this.zip(indices,proofHashes.slice(sliceStart,nextSliceStart))}const tree=[leafTuples];for(let layerIndex=0;layerIndex<proofTuplesByLayers.length;layerIndex++){const currentLayer=proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(((_ref5,_ref6)=>{let[indexA]=_ref5,[indexB]=_ref6;return indexA-indexB})).map((_ref7=>{let[,hash]=_ref7;return hash})),s=tree[layerIndex].map((_ref8=>{let[layerIndex_]=_ref8;return layerIndex_})),parentIndices=[...new Set(s.map((index=>index%2==0?index/2:index%2==0?(index+1)/2:(index-1)/2)))],parentLayer=[];for(let i=0;i<parentIndices.length;i++){const parentNodeTreeIndex=parentIndices[i],bufA=currentLayer[2*i],bufB=currentLayer[2*i+1],hash=bufB?this.hashFn(this.concatenator([bufA,bufB])):bufA;parentLayer.push([parentNodeTreeIndex,hash])}tree.push(parentLayer)}return tree[tree.length-1][0][1]}}var assertEnabled_d1700f0b_browser_esm=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js"),lib=__webpack_require__("./node_modules/zod/lib/index.mjs"),setErc20Allowance_7f76f677_browser_esm=__webpack_require__("./node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js");const esm_browser_native={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let getRandomValues;const rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}const byteToHex=[];for(let i=0;i<256;++i)byteToHex.push((i+256).toString(16).slice(1));function unsafeStringify(arr,offset=0){return byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+"-"+byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+"-"+byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+"-"+byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+"-"+byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]}const esm_browser_v4=function v4(options,buf,offset){if(esm_browser_native.randomUUID&&!buf&&!options)return esm_browser_native.randomUUID();const rnds=(options=options||{}).random||(options.rng||rng)();if(rnds[6]=15&rnds[6]|64,rnds[8]=63&rnds[8]|128,buf){offset=offset||0;for(let i=0;i<16;++i)buf[offset+i]=rnds[i];return buf}return unsafeStringify(rnds)};var signature_d3ea643d_browser_esm_console=__webpack_require__("./node_modules/console-browserify/index.js"),Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer;function abstractContractModelToLegacy(model){return{startTimestamp:model.startTimestamp,maxClaimableSupply:model.maxClaimableSupply,supplyClaimed:model.supplyClaimed,merkleRoot:model.merkleRoot,pricePerToken:model.pricePerToken,currency:model.currency,quantityLimitPerTransaction:model.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:model.waitTimeInSecondsBetweenClaims||0}}function abstractContractModelToNew(model){return{startTimestamp:model.startTimestamp,maxClaimableSupply:model.maxClaimableSupply,supplyClaimed:model.supplyClaimed,merkleRoot:model.merkleRoot,pricePerToken:model.pricePerToken,currency:model.currency,quantityLimitPerWallet:model.maxClaimablePerWallet,metadata:model.metadata||""}}function convertQuantityToBigNumber(quantity,tokenDecimals){return"unlimited"===quantity?bignumbers.Is:lib_esm.parseUnits(quantity,tokenDecimals)}async function parseSnapshotInputs(inputs){const chunks=Array.from({length:Math.ceil(inputs.length/25e3)},((_,i)=>inputs.slice(25e3*i,25e3*i+25e3))),results=[],parsedChunks=await Promise.all(chunks.map((chunk=>index_33cd3415_browser_esm.bM.parseAsync(chunk))));for(const chunk of parsedChunks)results.push(...chunk);return results}let SnapshotFormatVersion=function(SnapshotFormatVersion){return SnapshotFormatVersion[SnapshotFormatVersion.V1=1]="V1",SnapshotFormatVersion[SnapshotFormatVersion.V2=2]="V2",SnapshotFormatVersion}({});class ShardedMerkleTree{constructor(storage,baseUri,originalEntriesUri,shardNybbles,tokenDecimals){this.storage=storage,this.shardNybbles=shardNybbles,this.baseUri=baseUri,this.originalEntriesUri=originalEntriesUri,this.tokenDecimals=tokenDecimals,this.shards={},this.trees={}}static async fromUri(uri,storage){try{const shardedMerkleTreeInfo=await storage.downloadJSON(uri);if(shardedMerkleTreeInfo.isShardedMerkleTree)return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo,storage)}catch(e){return}}static async fromShardedMerkleTreeInfo(info,storage){return new ShardedMerkleTree(storage,info.baseUri,info.originalEntriesUri,info.shardNybbles,info.tokenDecimals)}static hashEntry(entry,tokenDecimals,currencyDecimals,snapshotFormatVersion){switch(snapshotFormatVersion){case SnapshotFormatVersion.V1:return solidity_lib_esm.keccak256(["address","uint256"],[entry.address,convertQuantityToBigNumber(entry.maxClaimable,tokenDecimals)]);case SnapshotFormatVersion.V2:return solidity_lib_esm.keccak256(["address","uint256","uint256","address"],[entry.address,convertQuantityToBigNumber(entry.maxClaimable,tokenDecimals),convertQuantityToBigNumber(entry.price||"unlimited",currencyDecimals),entry.currencyAddress||addresses.L])}}static async fetchAndCacheDecimals(cache,provider,currencyAddress){if(!currencyAddress)return 18;let currencyDecimals=cache[currencyAddress];if(void 0===currencyDecimals){currencyDecimals=(await(0,fetchCurrencyValue_32d08b05_browser_esm.f)(provider,currencyAddress)).decimals,cache[currencyAddress]=currencyDecimals}return currencyDecimals}static async buildAndUpload(snapshotInput,tokenDecimals,provider,storage,snapshotFormatVersion){let shardNybbles=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const inputs=await parseSnapshotInputs(snapshotInput),shards={};for(const snapshotEntry of inputs){const shard=snapshotEntry.address.slice(2,2+shardNybbles).toLowerCase();void 0===shards[shard]&&(shards[shard]=[]),shards[shard].push(snapshotEntry)}const currencyDecimalMap={},subTrees=await Promise.all(Object.entries(shards).map((async _ref=>{let[shard,entries]=_ref;return[shard,new thirdweb_dev_merkletree_esm_MerkleTree(await Promise.all(entries.map((async entry=>{const currencyDecimals=await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap,provider,entry.currencyAddress);return ShardedMerkleTree.hashEntry(entry,tokenDecimals,currencyDecimals,snapshotFormatVersion)}))),keccak256_lib_esm.keccak256,{sort:!0}).getHexRoot()]}))),roots=Object.fromEntries(subTrees),tree=new thirdweb_dev_merkletree_esm_MerkleTree(Object.values(roots),keccak256_lib_esm.keccak256,{sort:!0}),shardsToUpload=[];for(const[shardId,entries]of Object.entries(shards)){const data={proofs:tree.getProof(roots[shardId]).map((value=>"0x"+value.data.toString("hex"))),entries};shardsToUpload.push({data:JSON.stringify(data),name:`${shardId}.json`})}const uris=await storage.uploadBatch(shardsToUpload),baseUri=uris[0].slice(0,uris[0].lastIndexOf("/")),originalEntriesUri=await storage.upload(inputs),shardedMerkleInfo={merkleRoot:tree.getHexRoot(),baseUri,originalEntriesUri,shardNybbles,tokenDecimals,isShardedMerkleTree:!0};return{shardedMerkleInfo,uri:await storage.upload(shardedMerkleInfo)}}async getProof(address,provider,snapshotFormatVersion){const shardId=address.slice(2,2+this.shardNybbles).toLowerCase();let shard=this.shards[shardId];const currencyDecimalMap={};if(void 0===shard)try{const uri=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;shard=this.shards[shardId]=await this.storage.downloadJSON(`${uri}${shardId}.json`);const hashedEntries=await Promise.all(shard.entries.map((async entry=>{const currencyDecimals=await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap,provider,entry.currencyAddress);return ShardedMerkleTree.hashEntry(entry,this.tokenDecimals,currencyDecimals,snapshotFormatVersion)})));this.trees[shardId]=new thirdweb_dev_merkletree_esm_MerkleTree(hashedEntries,keccak256_lib_esm.keccak256,{sort:!0})}catch(e){return null}const entry=shard.entries.find((i=>i.address.toLowerCase()===address.toLowerCase()));if(!entry)return null;const currencyDecimals=await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap,provider,entry.currencyAddress),leaf=ShardedMerkleTree.hashEntry(entry,this.tokenDecimals,currencyDecimals,snapshotFormatVersion),proof=this.trees[shardId].getProof(leaf).map((i=>"0x"+i.data.toString("hex")));return index_33cd3415_browser_esm.bN.parseAsync({...entry,proof:proof.concat(shard.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return signature_d3ea643d_browser_esm_console.warn("Could not fetch original snapshot entries",e),[]}}}async function fetchSnapshotEntryForAddress(address,merkleRoot,merkleMetadata,provider,storage,snapshotFormatVersion){if(!merkleMetadata)return null;const snapshotUri=merkleMetadata[merkleRoot];if(snapshotUri){const raw=await storage.downloadJSON(snapshotUri);if(raw.isShardedMerkleTree&&raw.merkleRoot===merkleRoot){const merkleTree=await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw,storage);return await merkleTree.getProof(address,provider,snapshotFormatVersion)}const snapshotData=await index_33cd3415_browser_esm.bO.parseAsync(raw);if(merkleRoot===snapshotData.merkleRoot)return snapshotData.claims.find((c=>c.address.toLowerCase()===address.toLowerCase()))||null}return null}function legacyContractModelToAbstract(model){return{startTimestamp:model.startTimestamp,maxClaimableSupply:model.maxClaimableSupply,supplyClaimed:model.supplyClaimed,merkleRoot:model.merkleRoot.toString(),pricePerToken:model.pricePerToken,currency:model.currency,maxClaimablePerWallet:model.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:model.waitTimeInSecondsBetweenClaims}}function newContractModelToAbstract(model){return{startTimestamp:model.startTimestamp,maxClaimableSupply:model.maxClaimableSupply,supplyClaimed:model.supplyClaimed,merkleRoot:model.merkleRoot.toString(),pricePerToken:model.pricePerToken,currency:model.currency,maxClaimablePerWallet:model.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:model.metadata}}async function approveErc20Allowance(contractToApprove,currencyAddress,price,quantity,tokenDecimals){const signer=contractToApprove.getSigner(),provider=contractToApprove.getProvider(),ERC20Abi=(await Promise.resolve().then(__webpack_require__.t.bind(__webpack_require__,"./node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json",19))).default,erc20=new index_33cd3415_browser_esm.cs(signer||provider,currencyAddress,ERC20Abi,contractToApprove.options,contractToApprove.storage),owner=await contractToApprove.getSignerAddress(),spender=contractToApprove.address,allowance=await erc20.read("allowance",[owner,spender]),totalPrice=bignumber.gH.from(price).mul(bignumber.gH.from(quantity)).div(lib_esm.parseUnits("1",tokenDecimals));allowance.lt(totalPrice)&&await erc20.sendTransaction("approve",[spender,allowance.add(totalPrice)])}async function prepareClaim(addressToClaim,quantity,activeClaimCondition,merkleMetadataFetcher,tokenDecimals,contractWrapper,storage,checkERC20Allowance,snapshotFormatVersion){let maxClaimable=convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet,tokenDecimals),proofs=[bytes_lib_esm.hexZeroPad([0],32)],priceInProof=activeClaimCondition.price,currencyAddressInProof=activeClaimCondition.currencyAddress;try{if(!activeClaimCondition.merkleRootHash.toString().startsWith(addresses.L)){const snapshotEntry=await fetchSnapshotEntryForAddress(addressToClaim,activeClaimCondition.merkleRootHash.toString(),await merkleMetadataFetcher(),contractWrapper.getProvider(),storage,snapshotFormatVersion);if(snapshotEntry)proofs=snapshotEntry.proof,maxClaimable="unlimited"===snapshotEntry.maxClaimable?bignumbers.Is:lib_esm.parseUnits(snapshotEntry.maxClaimable,tokenDecimals),priceInProof=void 0===snapshotEntry.price||"unlimited"===snapshotEntry.price?bignumbers.Is:await(0,normalizePriceValue_9851c0eb_browser_esm.n)(contractWrapper.getProvider(),snapshotEntry.price,snapshotEntry.currencyAddress||addresses.L),currencyAddressInProof=snapshotEntry.currencyAddress||addresses.L;else if(snapshotFormatVersion===SnapshotFormatVersion.V1)throw new Error("No claim found for this address")}}catch(e){if("No claim found for this address"===e?.message)throw e;signature_d3ea643d_browser_esm_console.warn("failed to check claim condition merkle root hash, continuing anyways",e)}const overrides=await contractWrapper.getCallOverrides()||{},pricePerToken=priceInProof.toString()!==bignumbers.Is.toString()?priceInProof:activeClaimCondition.price,currencyAddress=currencyAddressInProof!==addresses.L?currencyAddressInProof:activeClaimCondition.currencyAddress;return pricePerToken.gt(0)&&((0,fetchCurrencyValue_32d08b05_browser_esm.i)(currencyAddress)?overrides.value=bignumber.gH.from(pricePerToken).mul(quantity).div(lib_esm.parseUnits("1",tokenDecimals)):checkERC20Allowance&&await approveErc20Allowance(contractWrapper,currencyAddress,pricePerToken,quantity,tokenDecimals)),{overrides,proofs,maxClaimable,price:pricePerToken,currencyAddress,priceInProof,currencyAddressInProof}}const CurrencySchema=(()=>lib.z.object({name:lib.z.string(),symbol:lib.z.string(),decimals:lib.z.number()}))(),CurrencyValueSchema=(()=>CurrencySchema.extend({value:index_33cd3415_browser_esm.b5,displayValue:lib.z.string()}))(),ClaimConditionMetadataSchema=(()=>lib.z.object({name:lib.z.string().optional()}).catchall(lib.z.unknown()))(),ClaimConditionInputSchema=(()=>lib.z.object({startTime:assertEnabled_d1700f0b_browser_esm.S,currencyAddress:lib.z.string().default(index_33cd3415_browser_esm.aV),price:index_33cd3415_browser_esm.cw.default(0),maxClaimableSupply:index_33cd3415_browser_esm.cA,maxClaimablePerWallet:index_33cd3415_browser_esm.cA,waitInSeconds:index_33cd3415_browser_esm.b6.default(0),merkleRootHash:index_33cd3415_browser_esm.cB.default(bytes_lib_esm.hexZeroPad([0],32)),snapshot:lib.z.optional(index_33cd3415_browser_esm.bM).nullable(),metadata:ClaimConditionMetadataSchema.optional()}))(),ClaimConditionInputArray=(()=>lib.z.array(ClaimConditionInputSchema))(),ClaimConditionOutputSchema=(()=>ClaimConditionInputSchema.extend({availableSupply:index_33cd3415_browser_esm.cA,currentMintSupply:index_33cd3415_browser_esm.cA,currencyMetadata:CurrencyValueSchema.default({value:bignumber.gH.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:index_33cd3415_browser_esm.b5,waitInSeconds:index_33cd3415_browser_esm.b5,startTime:index_33cd3415_browser_esm.b5.transform((n=>new Date(1e3*n.toNumber()))),snapshot:index_33cd3415_browser_esm.bM.optional().nullable()}))();async function processSnapshotData(claimConditionInputs,tokenDecimals,provider,storage,snapshotFormatVersion){const snapshotInfos=[],inputsWithSnapshots=await Promise.all(claimConditionInputs.map((async conditionInput=>{if(conditionInput.snapshot&&conditionInput.snapshot.length>0){const snapshotInfo=await async function createSnapshot(snapshotInput,tokenDecimals,provider,storage,snapshotFormatVersion){const input=await parseSnapshotInputs(snapshotInput),addresses=input.map((i=>i.address));if(new Set(addresses).size<addresses.length)throw new index_33cd3415_browser_esm.s;const tree=await ShardedMerkleTree.buildAndUpload(input,tokenDecimals,provider,storage,snapshotFormatVersion);return{merkleRoot:tree.shardedMerkleInfo.merkleRoot,snapshotUri:tree.uri}}(conditionInput.snapshot,tokenDecimals,provider,storage,snapshotFormatVersion);snapshotInfos.push(snapshotInfo),conditionInput.merkleRootHash=snapshotInfo.merkleRoot}else conditionInput.merkleRootHash=bytes_lib_esm.hexZeroPad([0],32);return conditionInput})));return{inputsWithSnapshots,snapshotInfos}}async function processClaimConditionInputs(claimConditionInputs,tokenDecimals,provider,storage,snapshotFormatVersion){const{inputsWithSnapshots,snapshotInfos}=await processSnapshotData(claimConditionInputs,tokenDecimals,provider,storage,snapshotFormatVersion),parsedInputs=await ClaimConditionInputArray.parseAsync(inputsWithSnapshots),sortedConditions=(await Promise.all(parsedInputs.map((c=>async function convertToContractModel(c,tokenDecimals,provider,storage){const currency=c.currencyAddress===addresses.L?index_33cd3415_browser_esm.aV:c.currencyAddress,maxClaimableSupply=convertQuantityToBigNumber(c.maxClaimableSupply,tokenDecimals),maxClaimablePerWallet=convertQuantityToBigNumber(c.maxClaimablePerWallet,tokenDecimals);let metadataOrUri;return c.metadata&&(metadataOrUri="string"==typeof c.metadata?c.metadata:await storage.upload(c.metadata)),{startTimestamp:c.startTime,maxClaimableSupply,supplyClaimed:0,maxClaimablePerWallet,pricePerToken:await(0,normalizePriceValue_9851c0eb_browser_esm.n)(provider,c.price,currency),currency,merkleRoot:c.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:c.waitInSeconds||0,metadata:metadataOrUri}}(c,tokenDecimals,provider,storage))))).sort(((a,b)=>function compare(a,b){const left=bignumber.gH.from(a),right=bignumber.gH.from(b);return left.eq(right)?0:left.gt(right)?1:-1}(a.startTimestamp,b.startTimestamp)));return{snapshotInfos,sortedConditions}}async function fetchSnapshot(merkleRoot,merkleMetadata,storage){if(!merkleMetadata)return null;const snapshotUri=merkleMetadata[merkleRoot];if(snapshotUri){const raw=await storage.downloadJSON(snapshotUri);if(raw.isShardedMerkleTree&&raw.merkleRoot===merkleRoot){const smt=await ShardedMerkleTree.fromUri(snapshotUri,storage);return smt?.getAllEntries()||null}{const snapshotData=await index_33cd3415_browser_esm.bO.parseAsync(raw);if(merkleRoot===snapshotData.merkleRoot)return snapshotData.claims.map((claim=>({address:claim.address,maxClaimable:claim.maxClaimable,price:claim.price,currencyAddress:claim.currencyAddress})))}}return null}function convertToReadableQuantity(bn,tokenDecimals){return bn.toString()===bignumbers.Is.toString()?"unlimited":lib_esm.formatUnits(bn,tokenDecimals)}async function transformResultToClaimCondition(pm,tokenDecimals,provider,merkleMetadata,storage,shouldDownloadSnapshot){const cv=await(0,fetchCurrencyValue_32d08b05_browser_esm.a)(provider,pm.currency,pm.pricePerToken),maxClaimableSupply=convertToReadableQuantity(pm.maxClaimableSupply,tokenDecimals),maxClaimablePerWallet=convertToReadableQuantity(pm.maxClaimablePerWallet,tokenDecimals),availableSupply=convertToReadableQuantity(bignumber.gH.from(pm.maxClaimableSupply).sub(pm.supplyClaimed),tokenDecimals),currentMintSupply=convertToReadableQuantity(pm.supplyClaimed,tokenDecimals);let resolvedMetadata;return pm.metadata&&(resolvedMetadata=await storage.downloadJSON(pm.metadata)),ClaimConditionOutputSchema.parseAsync({startTime:pm.startTimestamp,maxClaimableSupply,maxClaimablePerWallet,currentMintSupply,availableSupply,waitInSeconds:pm.waitTimeInSecondsBetweenClaims?.toString(),price:bignumber.gH.from(pm.pricePerToken),currency:pm.currency,currencyAddress:pm.currency,currencyMetadata:cv,merkleRootHash:pm.merkleRoot,snapshot:shouldDownloadSnapshot?await fetchSnapshot(pm.merkleRoot,merkleMetadata,storage):void 0,metadata:resolvedMetadata})}async function updateExistingClaimConditions(index,claimConditionInput,existingConditions){if(index>=existingConditions.length)throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);const priceDecimals=existingConditions[index].currencyMetadata.decimals,priceInWei=existingConditions[index].price,priceInTokens=lib_esm.formatUnits(priceInWei,priceDecimals),newConditionParsed=await ClaimConditionInputSchema.parseAsync({...existingConditions[index],price:priceInTokens,...claimConditionInput}),mergedConditionOutput=await ClaimConditionOutputSchema.parseAsync({...newConditionParsed,price:priceInWei});return existingConditions.map(((existingOutput,i)=>{let newConditionAtIndex;newConditionAtIndex=i===index?mergedConditionOutput:existingOutput;const formattedPrice=lib_esm.formatUnits(newConditionAtIndex.price,priceDecimals);return{...newConditionAtIndex,price:formattedPrice}}))}let ClaimEligibility=function(ClaimEligibility){return ClaimEligibility.NotEnoughSupply="There is not enough supply to claim.",ClaimEligibility.AddressNotAllowed="This address is not on the allowlist.",ClaimEligibility.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",ClaimEligibility.ClaimPhaseNotStarted="Claim phase has not started yet.",ClaimEligibility.AlreadyClaimed="You have already claimed the token.",ClaimEligibility.WrongPriceOrCurrency="Incorrect price or currency.",ClaimEligibility.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",ClaimEligibility.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",ClaimEligibility.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",ClaimEligibility.NoClaimConditionSet="There is no claim condition set.",ClaimEligibility.NoWallet="No wallet connected.",ClaimEligibility.Unknown="No claim conditions found.",ClaimEligibility}({});function resolveOrGenerateId(requestUId){if(void 0===requestUId){const buffer=Buffer.alloc(16);return esm_browser_v4({},buffer),bytes_lib_esm.hexlify(utf8.YW(buffer.toString("hex")))}return bytes_lib_esm.hexlify(requestUId)}const BaseSignaturePayloadInput=(()=>lib.z.object({to:index_33cd3415_browser_esm.b9.refine((address=>address.toLowerCase()!==addresses.L),{message:"Cannot create payload to mint to zero address"}),price:index_33cd3415_browser_esm.cw.default(0),currencyAddress:index_33cd3415_browser_esm.b8.default(index_33cd3415_browser_esm.aV),mintStartTime:assertEnabled_d1700f0b_browser_esm.S,mintEndTime:assertEnabled_d1700f0b_browser_esm.E,uid:lib.z.string().optional().transform((arg=>resolveOrGenerateId(arg))),primarySaleRecipient:index_33cd3415_browser_esm.b9.default(addresses.L)}))(),Signature20PayloadInput=(()=>BaseSignaturePayloadInput.extend({quantity:index_33cd3415_browser_esm.cw}))(),Signature20PayloadOutput=(()=>Signature20PayloadInput.extend({mintStartTime:index_33cd3415_browser_esm.b5,mintEndTime:index_33cd3415_browser_esm.b5}))(),Signature721PayloadInput=(()=>BaseSignaturePayloadInput.extend({metadata:setErc20Allowance_7f76f677_browser_esm.N,royaltyRecipient:lib.z.string().default(addresses.L),royaltyBps:index_33cd3415_browser_esm.cC.default(0)}))(),Signature721PayloadOutput=(()=>Signature721PayloadInput.extend({metadata:setErc20Allowance_7f76f677_browser_esm.N.default(""),uri:lib.z.string(),royaltyBps:index_33cd3415_browser_esm.b5,mintStartTime:index_33cd3415_browser_esm.b5,mintEndTime:index_33cd3415_browser_esm.b5}))(),Signature1155PayloadInput=(()=>Signature721PayloadInput.extend({metadata:setErc20Allowance_7f76f677_browser_esm.N.default(""),quantity:index_33cd3415_browser_esm.b6}))(),Signature1155PayloadInputWithTokenId=(()=>Signature1155PayloadInput.extend({tokenId:index_33cd3415_browser_esm.b6}))(),Signature1155PayloadOutput=(()=>Signature721PayloadOutput.extend({tokenId:index_33cd3415_browser_esm.b5,quantity:index_33cd3415_browser_esm.b5}))(),Signature721WithQuantityInput=(()=>Signature721PayloadInput.extend({metadata:setErc20Allowance_7f76f677_browser_esm.N.default(""),quantity:index_33cd3415_browser_esm.b5.default(1)}))(),Signature721WithQuantityOutput=(()=>Signature721PayloadOutput.extend({quantity:index_33cd3415_browser_esm.b5.default(1)}))(),MintRequest20=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],MintRequest721=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],MintRequest1155=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],MintRequest721withQuantity=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},"./node_modules/buffer-reverse/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer;module.exports=function reverse(src){for(var buffer=new Buffer(src.length),i=0,j=src.length-1;i<=j;++i,--j)buffer[i]=src[j],buffer[j]=src[i];return buffer}},"./node_modules/treeify/treeify.js":function(module){module.exports=function(){function makePrefix(key,last){var str=last?"":"";return str+=key?" ":""}function filterKeys(obj,hideFunctions){var keys=[];for(var branch in obj)obj.hasOwnProperty(branch)&&(hideFunctions&&"function"==typeof obj[branch]||keys.push(branch));return keys}function growBranch(key,root,last,lastStates,showValues,hideFunctions,callback){var lastKey,circular,line="",index=0,lastStatesCopy=lastStates.slice(0);if(lastStatesCopy.push([root,last])&&lastStates.length>0&&(lastStates.forEach((function(lastState,idx){idx>0&&(line+=(lastState[1]?" ":"")+"  "),circular||lastState[0]!==root||(circular=!0)})),line+=makePrefix(key,last)+key,showValues&&("object"!=typeof root||root instanceof Date)&&(line+=": "+root),circular&&(line+=" (circular ref.)"),callback(line)),!circular&&"object"==typeof root){var keys=filterKeys(root,hideFunctions);keys.forEach((function(branch){lastKey=++index===keys.length,growBranch(branch,root[branch],lastKey,lastStatesCopy,showValues,hideFunctions,callback)}))}}var Treeify={asLines:function(obj,showValues,hideFunctions,lineCallback){growBranch(".",obj,!1,[],showValues,"function"!=typeof hideFunctions&&hideFunctions,lineCallback||hideFunctions)},asTree:function(obj,showValues,hideFunctions){var tree="";return growBranch(".",obj,!1,[],showValues,hideFunctions,(function(line){tree+=line+"\n"})),tree}};return Treeify}()}}]);